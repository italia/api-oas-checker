"use strict";

//
// Boilerplate code generated by the transpiler,
//    the actual code is below.
function e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function t(e, t, o) {
  return e(o = {
    path: t, exports: {
    }
    , require(e, t) {
      return function () {
        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
      }
        (null == t && o.path)
    }
  }
    , o.exports), o.exports
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

const o = t((function (e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }
  ), t.isObject = void 0, t.isObject = function (e) {
    return null !== e && "object" == typeof e
  }
}));

//
// The actual code.
//
const n = t((function (e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }
  ), t.getAllOperations = void 0;
  const n = ["get", "head", "post", "put", "patch", "delete", "options", "trace"];
  t.getAllOperations = function* (paths) {
    if (!o.isObject(paths)) {
      return;
    }
    const t = { path: "", operation: "" } ;
    for (const idx of Object.keys(paths)) {
      const path = paths[idx];
      if (o.isObject(path)) {
        t.path = idx;
        for (const e of Object.keys(path)) {
          o.isObject(path[e]) && n.includes(e) && (t.operation = e, yield t)
        }
      }
    }
  }
}
));
//
// The exported function.
//
const checkSecurity = e(t((function (e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), 
  t.oasOpSecurityDefined = void 0, t.oasOpSecurityDefined = (globalSecurity, options) => {
    // console.log("input", input);
    // console.log("options", options);
    const errorList = [];
    const { schemesPath: s, nullable: nullable, methods: methods } = options;
    const { paths: paths } = globalSecurity;
    // const c = myget(globalSecurity, s);
    // const u = o.isObject(c) ? Object.keys(c) : [];
    // console.log("myget", c, u)
    for (const { path: path, operation: httpMethod } of n.getAllOperations(paths)) {
      // Skip methods not configured in `methods`.
      if (methods && Array.isArray(methods) && !methods.includes(httpMethod)) {
        continue;
      }
      let { security: operationSecurity } = paths[path][httpMethod];
      let securityRef = [path, httpMethod]
      if (operationSecurity === undefined) {
        operationSecurity = globalSecurity.security
        securityRef = ["$.security"]
      };
      // console.log("security", operationSecurity)
      if (!operationSecurity || operationSecurity.length === 0) {
        errorList.push({
            message: `Operation has undefined security scheme in ${securityRef}.`,
            path: ["paths", path, httpMethod, "security", s]
          })
      }

      if (Array.isArray(operationSecurity)) {
        for (const [idx, securityEntry] of operationSecurity.entries()) {
          if (!o.isObject(securityEntry)) {
            continue;
          }
          const securitySchemeIds = Object.keys(securityEntry);
          securitySchemeIds.length === 0 && (nullable === false) && errorList.push({
            message: `Operation referencing empty security scheme in ${securityRef}.`,
            path: ["paths", path, httpMethod, "security", idx]
          }
          )
        }
      }
    }
    return errorList
  }, t.default = t.oasOpSecurityDefined
}
)));
exports.default = checkSecurity;

