#
# These rules are based on the Italian Guidelines,
# which are meant to align the design and security requirements
# for the APIs provided by more that 20'000 administrations.
#
# Ruleset integrate the current HTTP specifications and a wide set of Best Current Practices
# currently adopted both in the private and the public sector.
#
# You can discuss the ruleset on github:
# - https://github.com/italia/api-oas-checker
#
extends: spectral:oas

rules:
    cache-control-parameter-undocumented:
        description: |-
            Cache usage SHOULD be extensively detailed in the `description` property
            to avoid data leaks or the usage of stale data.

            This rule should ensure in some way that the api provider
            documented extensively the cache usage to avoid data leaks
            or usage of stale data.
            The `no-transform` directive can
            be used in responses to avoid transforming proxies to
            modify (eg. compress) the content.

            For now this ruleset tests:
            * the presence of following keywords
              in the `description`: `max-age`, `private`, `no-store`, `no-cache`,
              `no-transform`.
            * that one and only one between Expires and Cache-Control is used.

            `Cache-Control` and `Expires` should not be used in conjunction,
            because `Cache-Control` overrides `Expires` when `max-age` is set.
            Instead if neither `Cache-Control` or `Expires` are set, clients MAY use heuristic cache
            like described in RFC7234.
        message: '[RFC7234] Cache usage SHOULD be documented when used.'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[parameters][?(@.in == "header" && @.name.match(/Cache-Control/i))]
        then:
        -   field: description
            function: truthy
        -   field: description
            function: pattern
            functionOptions:
                match: .*(max-age|private|no-store|no-cache|no-transform).*
    cache-responses-undocumented:
        description: |-
            Cache usage SHOULD be extensively detailed in the `description` property
            to avoid data leaks or the usage of stale data.

            This rule should ensure in some way that the api provider
            documented extensively the cache usage to avoid data leaks
            or usage of stale data.
            The `no-transform` directive can
            be used in responses to avoid transforming proxies to
            modify (eg. compress) the content.

            For now this ruleset tests:
            * the presence of following keywords
              in the `description`: `max-age`, `private`, `no-store`, `no-cache`,
              `no-transform`.
            * that one and only one between Expires and Cache-Control is used.

            `Cache-Control` and `Expires` should not be used in conjunction,
            because `Cache-Control` overrides `Expires` when `max-age` is set.
            Instead if neither `Cache-Control` or `Expires` are set, clients MAY use heuristic cache
            like described in RFC7234.
        message: '[RFC7234] Cache usage in responses SHOULD be documented in Cache-Control
            and/or Expires. {{error}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[responses][?(@property[0] == "2" )][headers].[?(@property.match(/Cache-Control|Expires/i))]
        then:
        -   field: description
            function: truthy
        -   field: description
            function: pattern
            functionOptions:
                match: .*(max-age|private|no-store|no-cache|no-transform).*
    cache-responses-indeterminate-behavior:
        description: |-
            Cache usage SHOULD be extensively detailed in the `description` property
            to avoid data leaks or the usage of stale data.

            This rule should ensure in some way that the api provider
            documented extensively the cache usage to avoid data leaks
            or usage of stale data.
            The `no-transform` directive can
            be used in responses to avoid transforming proxies to
            modify (eg. compress) the content.

            For now this ruleset tests:
            * the presence of following keywords
              in the `description`: `max-age`, `private`, `no-store`, `no-cache`,
              `no-transform`.
            * that one and only one between Expires and Cache-Control is used.

            `Cache-Control` and `Expires` should not be used in conjunction,
            because `Cache-Control` overrides `Expires` when `max-age` is set.
            Instead if neither `Cache-Control` or `Expires` are set, clients MAY use heuristic cache
            like described in RFC7234.
        message: '[RFC7234] {{error}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[responses][?(@property[0] == "2" )][headers]
        then:
        -   function: xor
            functionOptions:
                properties:
                - Expires
                - Cache-Control
    paths-kebab-case:
        description: |
            Paths should be kebab-case (e.g. `path-parameter`).

            See Italian recommendation RAC_REST_NAME_002.
        message: '[RAC_REST_NAME_002] {{property}} is not kebab-case: {{error}}'
        severity: warn
        recommended: true
        given: $.paths[*]~
        then:
            function: pattern
            functionOptions:
                match: ^(/[a-z0-9-.]+|/{[a-zA-Z0-9_]+})+$
    http-request-GET-no-body:
        description: |-
            A `GET` request MUST NOT accept a `requestBody`
            because this behavior is not interoperable.
            Moreover intermediaries such as reverse proxies
            are allowed to strip the content from `GET` requests.

            See RFC7231 for further information.
        message: '[RFC7231] A GET request MUST NOT accept a requestBody: {{error}}.'
        severity: error
        given: $.paths..get.requestBody
        then:
            function: undefined
    http-request-DELETE-no-body:
        description: "Sending a `requestBody` in a `DELETE` request \nis not considered\
            \ interoperable.\nMoreover intermediaries such as reverse proxies\nmight\
            \ strip the content from `DELETE` requests.\n\nSee RFC7231 for further\
            \ information."
        message: '[RFC7231] A DELETE request SHOULD NOT accept a requestBody: {{error}}.'
        severity: error
        given: $.paths..delete.requestBody
        then:
            function: undefined
    http-response-no-content-204-205:
        description: |-
            Responses with the following status codes usually expected to include a content, which might have zero length: 200, 201, 202, 203, 206.
            Responses with status code 204 and 205 MUST NOT include a content.
            See RFC7231 for further information.
        message: '[RFC7231] 204 and 205 responses MUST NOT have a content: {{error}}.'
        severity: error
        given: $..paths..responses[?(@property && @property.match("(204|205)") )]
        then:
            field: content
            function: falsy
    http-response-content-2xx:
        description: |-
            Responses with the following status codes usually expected to include a content, which might have zero length: 200, 201, 202, 203, 206.
            Responses with status code 204 and 205 MUST NOT include a content.
            See RFC7231 for further information.
        message: '[RFC7231] 200, 201, 202, 203 and 206 responses usually have a content:
            {{error}}.'
        severity: error
        given: $..paths..responses[?( @property && @property.match("(200|201|202|203|206)")
            )]
        then:
        -   field: content
            function: truthy
        -   field: content
            function: schema
            functionOptions:
                schema:
                    type: object
                    minProperties: 1
                    additionalProperties:
                        required:
                        - schema
    servers-use-https:
        description: |-
            Servers must use https to ensure the origin of the responses
            and protect the integrity and the  confidentiality of the communication.

            You can use `http://` only on sandboxes environment.
            Use `x-sandbox: true` to skip this kind of check.
        message: 'Non-sandbox url  {{value}} {{error}}. Add `x-sandbox: true` to skip
            this check on a specific server.'
        given:
        - $.servers[?(@["x-sandbox"] != true)]
        - $.paths..servers[?(@["x-sandbox"] != true)]
        severity: error
        recommended: true
        then:
            field: url
            function: pattern
            functionOptions:
                match: ^https://.*
    no-method-name-in-operationId:
        description: |-
            Avoid using method names in `operationId`s because it couples
            the API design with the implementation.

            An operation that edits an entry can be published with different methods,
            for example either POST, PUT or PATCH, and while evolving the API
            you could decide to associate an operationId with another method.

            You can use for example

            ```
            openapi: 3.0.1
            ...
            paths:
              /entries:
                get:
                  operationId: list_entries
                post:
                  operationId: create_entry
              /entries/{id}:
                put:
                  operationId: upsert_entry
                patch:
                  operationId: edit_entry
            ```
        message: Avoid using method names in operationIds.
        formats:
        - oas3
        severity: error
        given: $..[?(@.operationId && @.operationId.match && @.operationId.match(/^(get|post|put|delete|patch|head)/i)
            )]
        then:
            field: operationId
            function: pattern
            functionOptions:
                match: //
    number-format:
        description: |-
            Schema of type number or integer must specify a format
            to express the associated datatype, eg. `int32`, `int64`, ...

            You can express similar requirements using the `minimum` and `maximum` properties.

            See recommendation RAC_REST_FORMAT_004.
        message: '[RAC_REST_FORMAT_004] Schema of type number or integer must specify
            a format. {{path}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[?(@ && @.type=="number")]
        then:
            field: format
            function: truthy
    integer-format:
        description: |-
            Schema of type number or integer must specify a format
            to express the associated datatype, eg. `int32`, `int64`, ...

            You can express similar requirements using the `minimum` and `maximum` properties.

            See recommendation RAC_REST_FORMAT_004.
        message: '[RAC_REST_FORMAT_004] Schema of type number or integer must specify
            a format. {{path}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[?(@ && @.type=="integer")]
        then:
            field: format
            function: truthy
    allowed-integer-format:
        description: |-
            To improve interoperability, integer and number formats are constrained
            to a shared subset.

            See recommendation RAC_REST_FORMAT_004.
        message: '[RAC_REST_FORMAT_004] Type format is "{{value}}", expected one of
            [int32, int64]. {{path}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[?(@ && @.type=="integer")]
        then:
            field: format
            function: enumeration
            functionOptions:
                values:
                - int32
                - int64
    allowed-number-format:
        description: |-
            To improve interoperability, integer and number formats are constrained
            to a shared subset.

            See recommendation RAC_REST_FORMAT_004.
        message: '[RAC_REST_FORMAT_004] Type format is "{{value}}", expected one of
            [decimal32, decimal64, decimal128, float, double]. {{path}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[?(@ && @.type=="number")]
        then:
            field: format
            function: enumeration
            functionOptions:
                values:
                - decimal32
                - decimal64
                - float
                - double
                - decimal128
    no-swagger-2:
        description: Swagger 2 files are not allowed. Use OpenAPI >= 3.0
        given: $
        severity: error
        recommended: true
        type: style
        formats:
        - oas2
        then:
            field: swagger
            function: falsy
    paths-status:
        description: |-
            You must define a `/status` path that can be used to health-check the API.
            Using this path avoids the arbitrary usage of a server URL for health-check
            scope.

            The `/status` endpoint should return a `application/problem+json` response
            containing a successful status code if the service is working correctly.

            The service provider is free to define the implementation logic for this path.
        message: The "/status" path used to health-check the API must be defined.
            {{error}}
        severity: error
        recommended: true
        given: $.paths
        then:
            function: schema
            functionOptions:
                schema:
                    oneOf:
                    -   type: object
                        required:
                        - /status
                        properties:
                            /status:
                                type: object
                    -   type: object
                        additionalProperties: false
    paths-status-return-problem:
        description: '"/status" must return a Problem object.'
        message: '{{error}}'
        severity: error
        recommended: true
        given: $.paths.'/status'.get.responses.200.content.*~
        then:
            function: enumeration
            functionOptions:
                values:
                - application/problem+xml
                - application/problem+json
    paths-status-problem-schema:
        description: '"/status" schema is not a Problem object.'
        message: '{{error}} {{path}}'
        severity: error
        recommended: true
        given: $.paths.'/status'.get.responses.200.content.[schema]
        then:
        -   function: truthy
            field: properties.status
        -   function: truthy
            field: properties.title
        -   function: truthy
            field: properties.detail
    use-problem-json-for-errors:
        description: |4-

            Error management is a key enabler of a resilient API ecosystem.
            Enforcing a consistent schema for errors between different APIs,
            enables client to properly implement an error management strategy,
            with positive impacts for users.

            Error responses should return one of the media-type
            defined in RFC7807:
            - `application/problem+json`
            - `application/problem+xml`

            An example of a valid response:

            ```
            responses:
              "503":
                content:
                  application/problem+json:
                    schema:
                      ...
            ```
        message: '[RFC7807] Error responses should support RFC7807 in {{path}}.'
        formats:
        - oas3
        severity: error
        given: $.paths.[*].responses[?(@property && @property.match(/^(4|5|default)/)
            && !@["x-noqa"] )].content.*~
        then:
            function: enumeration
            functionOptions:
                values:
                - application/problem+xml
                - application/problem+json
    use-problem-schema:
        description: |-
            WARN: This rule is under implementation and just provides an hint.

            Error management is a key enabler of a resilient API ecosystem.
            Enforcing a consistent schema for errors between different APIs,
            enables client to properly implement an error management strategy,
            with positive impacts for users.

            This rule inspects the schema returned by an error response and
            verifies whether it contains the main properties defined in RFC7807:
            `status`, `title` and `detail`.

            An example of a valid payload is
            ```
            {
             "title": "Not Found",
             "status": 404,
             "detail": "Book does not exist; id: 123"
            }
            ```

            See recommendation RAC_REST_NAME_007.
        message: '[RFC7807] Your schema doesn''t seem to match RFC7807. Are you sure
            it is ok? {{path}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[responses][?(@property && @property.match(/^(4|5|default)/)  &&
            !@["x-noqa"] )][schema].properties
        then:
            function: schema
            functionOptions:
                schema:
                    anyOf:
                    -   type: object
                        required:
                        - title
                        - status
                    -   type: object
                        required:
                        - title
                        - type
                    -   type: object
                        required:
                        - type
                        - status
                    -   type: object
                        required:
                        - title
                        - detail
    missing-retry-after:
        description: |-
            When a client is either:
            * throttled out with a 429 status code;
            * warned about a temporary server issue with a 503 status code;
            the server should explicitly communicate how long to wait
            before issuing further requests using the Retry-After header.

            Retry-After is defined in RFC7231.
        message: '[RFC7231] Missing ratelimit header: {{property}} in {{path}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[responses][?(@property == "429" || @property == "503"  )][headers]
        then:
            field: Retry-After
            function: truthy
    missing-ratelimit:
        description: |-
            Ratelimiting an API preserves a service and limits attack scenario
            [see API4:2019 Lack of Resources & Rate Limiting](https://owasp.org/www-project-api-security).

            APIs should use the following headers at least on successful responses:
            - `X-RateLimit-Limit`: number of total requests in a give time window
            - `X-RateLimit-Remaining`: remaining requests in the current window
            - `X-RateLimit-Reset`: number of seconds before the window resets

            An example set of headers is the following

            ```
            X-Ratelimit-Limit: 100
            X-Ratelimit-Remaining: 40
            X-Ratelimit-Reset: 12
            ```

            A standardization proposal for ratelimit headers is ongoing
            inside the IETF HTTPAPI Workgroup.
            See [the draft](https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/)
        message: Missing ratelimit headers. {{property}} {{error}} {{path}}
        formats:
        - oas3
        severity: error
        recommended: true
        given: $..[responses][?(@property[0] == "2" )][headers]
        then:
        -   functionOptions:
                properties:
                - X-RateLimit-Limit
                - RateLimit-Limit
            function: xor
        -   functionOptions:
                properties:
                - X-RateLimit-Remaining
                - RateLimit-Remaining
            function: xor
        -   functionOptions:
                properties:
                - X-RateLimit-Reset
                - RateLimit-Reset
            function: xor
    sec-apikeys-url:
        description: |-
            API Keys are (usually opaque) strings that
            are passed in headers, cookies or query parameters
            to access APIs.

            Those keys can be eavesdropped, especially when they are stored
            in cookies or passed as URL parameters.

            ```
            security:
            - ApiKey: []
            paths:
              /books: {}
              /users: {}
            securitySchemes:
              ApiKey:
                type: apiKey
                in: cookie
                name: X-Api-Key
            ```
        message: 'ApiKey passed in URL: {{error}}.'
        formats:
        - oas3
        severity: error
        recommended: true
        given:
        - $..[securitySchemes][?(@ && @.type=="apiKey")].in
        then:
        -   function: pattern
            functionOptions:
                notMatch: ^(query)$
    sec-credentials-parameters:
        description: |-
            URL parameters MUST NOT contain credentials such as
            apikey, password, or secret.

            See [RAC_GEN_004](https://docs.italia.it/italia/piano-triennale-ict/lg-modellointeroperabilita-docs/it/bozza/doc/04_Raccomandazioni%20di%20implementazione/04_raccomandazioni-tecniche-generali/01_globali.html?highlight=credenziali#rac-gen-004-non-passare-credenziali-o-dati-riservati-nellurl)
        message: '[RAC_GEN_004] Credentials are sent via URLs. {{path}} {{error}}'
        formats:
        - oas3
        severity: error
        recommended: true
        given:
        - $..parameters[?(@ && @.in && @.in.match(/query|path/))].name
        then:
        -   field: name
            function: pattern
            functionOptions:
                notMatch: /^.*(password|secret|apikey).*$/i
