#	Ruleset name: Italian Guidelines
#	Ruleset version: 1.2

#
# These rules are based on the Italian Guidelines,
# which are meant to align the design and security requirements
# for the APIs provided by more that 20'000 administrations.
#
# Ruleset integrate the current HTTP specifications and a wide set of Best Current Practices
# currently adopted both in the private and the public sector.
#
# You can discuss the ruleset on github:
# - https://github.com/italia/api-oas-checker
#
extends: spectral:oas

rules:
    cache-control-parameter-undocumented:
        description: |-
            Cache usage SHOULD be extensively detailed in the `description` property
            to avoid data leaks or the usage of stale data.

            This rule should ensure in some way that the api provider
            documented extensively the cache usage to avoid data leaks
            or usage of stale data.
            The `no-transform` directive can
            be used in responses to avoid transforming proxies to
            modify (eg. compress) the content.

            For now this ruleset tests:
            * the presence of following keywords
              in the `description`: `max-age`, `private`, `no-store`, `no-cache`,
              `no-transform`.
            * that one and only one between Expires and Cache-Control is used.

            `Cache-Control` and `Expires` should not be used in conjunction,
            because `Cache-Control` overrides `Expires` when `max-age` is set.
            Instead if neither `Cache-Control` or `Expires` are set, clients MAY use heuristic cache
            like described in RFC7234.
        message: '[RFC7234] Cache usage SHOULD be documented when used.'
        formats:
        - oas3
        severity: warn
        recommended: true
        given: $..[parameters][?(@.in == "header" && @.name.match(/Cache-Control/i))]
        then:
        -   field: description
            function: truthy
        -   field: description
            function: pattern
            functionOptions:
                match: .*(max-age|private|no-store|no-cache|no-transform).*
    cache-responses-undocumented:
        description: |-
            Cache usage SHOULD be extensively detailed in the `description` property
            to avoid data leaks or the usage of stale data.

            This rule should ensure in some way that the api provider
            documented extensively the cache usage to avoid data leaks
            or usage of stale data.
            The `no-transform` directive can
            be used in responses to avoid transforming proxies to
            modify (eg. compress) the content.

            For now this ruleset tests:
            * the presence of following keywords
              in the `description`: `max-age`, `private`, `no-store`, `no-cache`,
              `no-transform`.
            * that one and only one between Expires and Cache-Control is used.

            `Cache-Control` and `Expires` should not be used in conjunction,
            because `Cache-Control` overrides `Expires` when `max-age` is set.
            Instead if neither `Cache-Control` or `Expires` are set, clients MAY use heuristic cache
            like described in RFC7234.
        message: '[RFC7234] Cache usage in responses SHOULD be documented in Cache-Control
            and/or Expires. {{error}}'
        formats:
        - oas3
        severity: info
        recommended: true
        given: $..[responses][?(@property[0] == "2" )][headers].[?(@property.match(/Cache-Control|Expires/i))]
        then:
        -   field: description
            function: truthy
        -   field: description
            function: pattern
            functionOptions:
                match: .*(max-age|private|no-store|no-cache|no-transform).*
    cache-responses-indeterminate-behavior:
        description: |-
            Cache usage SHOULD be extensively detailed in the `description` property
            to avoid data leaks or the usage of stale data.

            This rule should ensure in some way that the api provider
            documented extensively the cache usage to avoid data leaks
            or usage of stale data.
            The `no-transform` directive can
            be used in responses to avoid transforming proxies to
            modify (eg. compress) the content.

            For now this ruleset tests:
            * the presence of following keywords
              in the `description`: `max-age`, `private`, `no-store`, `no-cache`,
              `no-transform`.
            * that one and only one between Expires and Cache-Control is used.

            `Cache-Control` and `Expires` should not be used in conjunction,
            because `Cache-Control` overrides `Expires` when `max-age` is set.
            Instead if neither `Cache-Control` or `Expires` are set, clients MAY use heuristic cache
            like described in RFC7234.
        message: '[RFC7234] {{error}}'
        formats:
        - oas3
        severity: info
        recommended: true
        given: $..[responses][?(@property[0] == "2" )][headers]
        then:
        -   function: xor
            functionOptions:
                properties:
                - Expires
                - Cache-Control
    http-request-DELETE-no-body:
        description: "Sending a `requestBody` in a `DELETE` request \nis not considered\
            \ interoperable.\nMoreover intermediaries such as reverse proxies\nmight\
            \ strip the content from `DELETE` requests.\n\nSee RFC7231 for further\
            \ information."
        message: '[RFC7231] A DELETE request SHOULD NOT accept a requestBody: {{error}}.'
        severity: warn
        given: $.paths..delete.requestBody
        then:
            function: undefined
    http-response-content-2xx:
        description: |-
            Responses with the following status codes usually expected to include a content, which might have zero length: 200, 201, 202, 203, 206.
            Responses with status code 204 and 205 MUST NOT include a content.
            See RFC7231 for further information.
        message: '[RFC7231] 200, 201, 202, 203 and 206 responses usually have a content:
            {{error}}.'
        severity: hint
        given: $..paths..responses[?( @property && @property.match("(200|201|202|203|206)")
            )]
        then:
        -   field: content
            function: truthy
        -   field: content
            function: schema
            functionOptions:
                schema:
                    type: object
                    minProperties: 1
                    additionalProperties:
                        required:
                        - schema
    no-method-name-in-operationId:
        description: |-
            Avoid using method names in `operationId`s because it couples
            the API design with the implementation.

            An operation that edits an entry can be published with different methods,
            for example either POST, PUT or PATCH, and while evolving the API
            you could decide to associate an operationId with another method.

            You can use for example

            ```
            openapi: 3.0.1
            ...
            paths:
              /entries:
                get:
                  operationId: list_entries
                post:
                  operationId: create_entry
              /entries/{id}:
                put:
                  operationId: upsert_entry
                patch:
                  operationId: edit_entry
            ```
        message: Avoid using method names in operationIds.
        formats:
        - oas3
        severity: hint
        given: $..[?(@.operationId && @.operationId.match && @.operationId.match(/^(get|post|put|delete|patch|head)/i)
            )]
        then:
            field: operationId
            function: pattern
            functionOptions:
                match: //
    allowed-integer-format:
        description: |-
            To improve interoperability, integer and number formats are constrained
            to a shared subset.

            See recommendation RAC_REST_FORMAT_004.
        message: '[RAC_REST_FORMAT_004] Type format is "{{value}}", expected one of
            [int32, int64]. {{path}}'
        formats:
        - oas3
        severity: hint
        recommended: true
        given: $..[?(@ && @.type=="integer")]
        then:
            field: format
            function: enumeration
            functionOptions:
                values:
                - int32
                - int64
    allowed-number-format:
        description: |-
            To improve interoperability, integer and number formats are constrained
            to a shared subset.

            See recommendation RAC_REST_FORMAT_004.
        message: '[RAC_REST_FORMAT_004] Type format is "{{value}}", expected one of
            [decimal32, decimal64, decimal128, float, double]. {{path}}'
        formats:
        - oas3
        severity: hint
        recommended: true
        given: $..[?(@ && @.type=="number")]
        then:
            field: format
            function: enumeration
            functionOptions:
                values:
                - decimal32
                - decimal64
                - float
                - double
                - decimal128
    paths-status-problem-schema:
        description: '"/status" schema is not a Problem object.'
        message: '{{error}} {{path}}'
        severity: warn
        recommended: true
        given: $.paths.'/status'.get.responses.200.content.[schema]
        then:
        -   function: truthy
            field: properties.status
        -   function: truthy
            field: properties.title
        -   function: truthy
            field: properties.detail
    use-problem-schema:
        description: |-
            WARN: This rule is under implementation and just provides an hint.

            Error management is a key enabler of a resilient API ecosystem.
            Enforcing a consistent schema for errors between different APIs,
            enables client to properly implement an error management strategy,
            with positive impacts for users.

            This rule inspects the schema returned by an error response and
            verifies whether it contains the main properties defined in RFC7807:
            `status`, `title` and `detail`.

            An example of a valid payload is
            ```
            {
             "title": "Not Found",
             "status": 404,
             "detail": "Book does not exist; id: 123"
            }
            ```

            See recommendation RAC_REST_NAME_007.
        message: '[RFC7807] Your schema doesn''t seem to match RFC7807. Are you sure
            it is ok? {{path}}'
        formats:
        - oas3
        severity: hint
        recommended: true
        given: $..[responses][?(@property && @property.match(/^(4|5|default)/)  &&
            !@["x-noqa"] )][schema].properties
        then:
            function: schema
            functionOptions:
                schema:
                    anyOf:
                    -   type: object
                        required:
                        - title
                        - status
                    -   type: object
                        required:
                        - title
                        - type
                    -   type: object
                        required:
                        - type
                        - status
                    -   type: object
                        required:
                        - title
                        - detail
    missing-retry-after:
        description: |-
            When a client is either:
            * throttled out with a 429 status code;
            * warned about a temporary server issue with a 503 status code;
            the server should explicitly communicate how long to wait
            before issuing further requests using the Retry-After header.

            Retry-After is defined in RFC7231.
        message: '[RFC7231] Missing ratelimit header: {{property}} in {{path}}'
        formats:
        - oas3
        severity: warn
        recommended: true
        given: $..[responses][?(@property == "429" || @property == "503"  )][headers]
        then:
            field: Retry-After
            function: truthy
    missing-ratelimit:
        description: |-
            Ratelimiting an API preserves a service and limits attack scenario
            [see API4:2019 Lack of Resources & Rate Limiting](https://owasp.org/www-project-api-security).

            APIs should use the following headers at least on successful responses:
            - `X-RateLimit-Limit`: number of total requests in a give time window
            - `X-RateLimit-Remaining`: remaining requests in the current window
            - `X-RateLimit-Reset`: number of seconds before the window resets

            An example set of headers is the following

            ```
            X-Ratelimit-Limit: 100
            X-Ratelimit-Remaining: 40
            X-Ratelimit-Reset: 12
            ```

            A standardization proposal for ratelimit headers is ongoing
            inside the IETF HTTPAPI Workgroup.
            See [the draft](https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/)
        message: Missing ratelimit headers. {{property}} {{error}} {{path}}
        formats:
        - oas3
        severity: warn
        recommended: true
        given: $..[responses][?(@property[0] == "2" )][headers]
        then:
        -   functionOptions:
                properties:
                - X-RateLimit-Limit
                - RateLimit-Limit
            function: xor
        -   functionOptions:
                properties:
                - X-RateLimit-Remaining
                - RateLimit-Remaining
            function: xor
        -   functionOptions:
                properties:
                - X-RateLimit-Reset
                - RateLimit-Reset
            function: xor
