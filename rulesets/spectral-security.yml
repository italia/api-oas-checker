#	Ruleset name: Extra Security Checks
#	Ruleset version: 1.2

#
# These rules are based on the Italian Guidelines,
# which are meant to align the design and security requirements
# for the APIs provided by more that 20'000 administrations.
#
# Ruleset integrate the current HTTP specifications and a wide set of Best Current Practices
# currently adopted both in the private and the public sector.
#
# You can discuss the ruleset on github:
# - https://github.com/italia/api-oas-checker
#
extends: spectral:oas

rules:
    sec-array-boundaries:
        description: |-
            Array size should be limited to mitigate resource exhaustion attacks.
            This can be done using `maxItems` and `minItems`, like in the example
            below.

            ```
            Limited:
              type: array
              maxItems: 10
              items:
                type: string
                format: date
            ```

            You should ensure that the schema referenced in  `items` is constrained too.

            If you delegate input validation to a library or framework,
            be sure to test it thoroughly and ensure that it verifies `maxItems`.
        message: Schema of type array must specify maxItems and minItems. {{path}}
            {{error}}
        formats:
        - oas3
        severity: warn
        recommended: true
        given:
        - $..[?(@.type=="array")]
        then:
        -   field: maxItems
            function: defined
        -   field: minItems
            function: defined
    sec-number-boundaries:
        description: |-
            Numeric values should be limited in size to mitigate resource exhaustion
            using `maximum` and `minimum`.

            If you delegate input validation to a library or framework,
            be sure to test it thoroughly.
        message: Schema of type number or integer must specify a maximum and a minimum.
            {{path}} {{error}}
        formats:
        - oas3
        severity: warn
        recommended: true
        given:
        - $..[?(@.type=="number")]
        - $..[?(@.type=="integer")]
        then:
        -   field: maximum
            function: defined
        -   field: minimum
            function: defined
    sec-no-additionalProperties:
        description: |-
            By default, jsonschema allows additionalProperties. This means
            that schema validators can be bypassed using further, unspecified
            fields.

            While forbidding additionalProperties can create rigidity and hinder
            the evolution of an API - eg making it hard to accept new parameters
            or fields - it is possible that this flexibility can be used
            to bypass the schema validator and force the application to process
            unwanted information.

            Disable `additionalProperties` with `false`

            ```
            Person:
              type: object
              additionalProperties: false
              properties:
                given_name:
                  type: string
                  pattern: [a-zA-Z ]{24}
            ```

            Or constraint them using `maxProperties`

            ```
            Person:
              type: object
              additionalProperties:
                type: string
                pattern: /+39[0-9]{,14}/
              maxProperties: 3
              properties:
                given_name:
                  type: string
                  pattern: [a-zA-Z ]{24}
            ```
            - no additionalProperties
            - constrained additionalProperties
        message: 'Objects should not allow unconstrained additionalProperties. Disable
            them with `additionalProperties: false` or add `maxProperties`.'
        formats:
        - oas3
        severity: warn
        recommended: true
        given:
        - $..[?(@.type=="object" && @.additionalProperties==true)]
        then:
        -   field: additionalProperties
            function: falsy
    sec-no-default-additionalProperties:
        description: |-
            By default, jsonschema allows additionalProperties. This means
            that schema validators can be bypassed using further, unspecified
            fields.

            While forbidding additionalProperties can create rigidity and hinder
            the evolution of an API - eg making it hard to accept new parameters
            or fields - it is possible that this flexibility can be used
            to bypass the schema validator and force the application to process
            unwanted information.

            Disable `additionalProperties` with `false`

            ```
            Person:
              type: object
              additionalProperties: false
              properties:
                given_name:
                  type: string
                  pattern: [a-zA-Z ]{24}
            ```

            Or constraint them using `maxProperties`

            ```
            Person:
              type: object
              additionalProperties:
                type: string
                pattern: /+39[0-9]{,14}/
              maxProperties: 3
              properties:
                given_name:
                  type: string
                  pattern: [a-zA-Z ]{24}
            ```
            - no additionalProperties
            - constrained additionalProperties
        message: 'Objects should not allow unconstrained additionalProperties. Disable
            them with `additionalProperties: false` or add `maxProperties`.'
        formats:
        - oas3
        severity: warn
        recommended: true
        given:
        - $..[?(@.type=="object" && ! @.additionalProperties)]
        then:
        -   field: additionalProperties
            function: defined
    sec-constrained-additionalProperties:
        description: |-
            By default, jsonschema allows additionalProperties. This means
            that schema validators can be bypassed using further, unspecified
            fields.

            While forbidding additionalProperties can create rigidity and hinder
            the evolution of an API - eg making it hard to accept new parameters
            or fields - it is possible that this flexibility can be used
            to bypass the schema validator and force the application to process
            unwanted information.

            Disable `additionalProperties` with `false`

            ```
            Person:
              type: object
              additionalProperties: false
              properties:
                given_name:
                  type: string
                  pattern: [a-zA-Z ]{24}
            ```

            Or constraint them using `maxProperties`

            ```
            Person:
              type: object
              additionalProperties:
                type: string
                pattern: /+39[0-9]{,14}/
              maxProperties: 3
              properties:
                given_name:
                  type: string
                  pattern: [a-zA-Z ]{24}
            ```
            - no additionalProperties
            - constrained additionalProperties
        message: 'Objects should not allow unconstrained additionalProperties. Disable
            them with `additionalProperties: false` or add `maxProperties`.'
        formats:
        - oas3
        severity: warn
        recommended: true
        given:
        - $..[?(@.type=="object" && @.additionalProperties &&  @.additionalProperties!=true
            &&  @.additionalProperties!=false )]
        then:
        -   field: maxProperties
            function: defined
    sec-protection-global-unsafe:
        description: "Check if the operation is protected at operation level.\nOtherwise,\
            \ the global `#/security` property is check.\n\nYour API should be protected\
            \ by a `security` rule either at\nglobal or operation level.\nAll operations\
            \ should be protected especially when they\nnot safe (methods that do\
            \ not alter the state of the server) \nHTTP methods like `POST`, `PUT`,\
            \ `PATCH` and `DELETE`.\nThis is done with one or more non-empty `security`\
            \ rules.\n\nSecurity rules are defined in the `securityScheme` section.\n\
            \nAn example of a security rule applied at global level.\n\n```\nsecurity:\n\
            - BasicAuth: []\npaths:\n  /books: {}\n  /users: {}\nsecuritySchemes:\n\
            \  BasicAuth:\n    scheme: http\n    type: basic\n```\n\nAn example of\
            \ a security rule applied at operation level, which\neventually overrides\
            \ the global one\n\n```\npaths:\n  /books:\n    post:\n      security:\n\
            \      - AccessToken: []\nsecuritySchemes:\n  BasicAuth:\n    scheme:\
            \ http\n    type: basic\n  AccessToken:\n    scheme: http\n    type: bearer\n\
            \    bearerFormat: JWT\n```\n\nIf your [safe methods](https://www.rfc-editor.org/rfc/rfc9110.html#name-safe-methods)\
            \ (e.g. GET, HEAD) don't need to be protected,\nyou need to state it explicitly\
            \ using an empty security rule: \n\n```\nsecurity:\n- {}\n```\n\nThis\
            \ can be done at operation level or at global level, but the latter is\n\
            discouraged because it will affect unsafe methods too."
        message: 'The following unsafe operation is not protected by a `security`
            rule: {{path}}'
        severity: error
        given: $
        then:
        -   function: checkSecurity
            functionOptions:
                schemesPath:
                - securitySchemes
                nullable: true
                methods:
                - post
                - patch
                - delete
                - put
    sec-protection-global-unsafe-strict:
        description: "Check if the operation is protected at operation level.\nOtherwise,\
            \ the global `#/security` property is check.\n\nYour API should be protected\
            \ by a `security` rule either at\nglobal or operation level.\nAll operations\
            \ should be protected especially when they\nnot safe (methods that do\
            \ not alter the state of the server) \nHTTP methods like `POST`, `PUT`,\
            \ `PATCH` and `DELETE`.\nThis is done with one or more non-empty `security`\
            \ rules.\n\nSecurity rules are defined in the `securityScheme` section.\n\
            \nAn example of a security rule applied at global level.\n\n```\nsecurity:\n\
            - BasicAuth: []\npaths:\n  /books: {}\n  /users: {}\nsecuritySchemes:\n\
            \  BasicAuth:\n    scheme: http\n    type: basic\n```\n\nAn example of\
            \ a security rule applied at operation level, which\neventually overrides\
            \ the global one\n\n```\npaths:\n  /books:\n    post:\n      security:\n\
            \      - AccessToken: []\nsecuritySchemes:\n  BasicAuth:\n    scheme:\
            \ http\n    type: basic\n  AccessToken:\n    scheme: http\n    type: bearer\n\
            \    bearerFormat: JWT\n```\n\nIf your [safe methods](https://www.rfc-editor.org/rfc/rfc9110.html#name-safe-methods)\
            \ (e.g. GET, HEAD) don't need to be protected,\nyou need to state it explicitly\
            \ using an empty security rule: \n\n```\nsecurity:\n- {}\n```\n\nThis\
            \ can be done at operation level or at global level, but the latter is\n\
            discouraged because it will affect unsafe methods too."
        message: 'The following unsafe operation is not protected by a `security`
            rule: {{path}}'
        severity: info
        given: $
        then:
        -   function: checkSecurity
            functionOptions:
                schemesPath:
                - securitySchemes
                nullable: false
                methods:
                - post
                - patch
                - delete
                - put
    sec-protection-global-safe:
        description: "Check if the operation is protected at operation level.\nOtherwise,\
            \ the global `#/security` property is check.\n\nYour API should be protected\
            \ by a `security` rule either at\nglobal or operation level.\nAll operations\
            \ should be protected especially when they\nnot safe (methods that do\
            \ not alter the state of the server) \nHTTP methods like `POST`, `PUT`,\
            \ `PATCH` and `DELETE`.\nThis is done with one or more non-empty `security`\
            \ rules.\n\nSecurity rules are defined in the `securityScheme` section.\n\
            \nAn example of a security rule applied at global level.\n\n```\nsecurity:\n\
            - BasicAuth: []\npaths:\n  /books: {}\n  /users: {}\nsecuritySchemes:\n\
            \  BasicAuth:\n    scheme: http\n    type: basic\n```\n\nAn example of\
            \ a security rule applied at operation level, which\neventually overrides\
            \ the global one\n\n```\npaths:\n  /books:\n    post:\n      security:\n\
            \      - AccessToken: []\nsecuritySchemes:\n  BasicAuth:\n    scheme:\
            \ http\n    type: basic\n  AccessToken:\n    scheme: http\n    type: bearer\n\
            \    bearerFormat: JWT\n```\n\nIf your [safe methods](https://www.rfc-editor.org/rfc/rfc9110.html#name-safe-methods)\
            \ (e.g. GET, HEAD) don't need to be protected,\nyou need to state it explicitly\
            \ using an empty security rule: \n\n```\nsecurity:\n- {}\n```\n\nThis\
            \ can be done at operation level or at global level, but the latter is\n\
            discouraged because it will affect unsafe methods too."
        message: 'The following operation is not protected by a `security` rule: {{path}}'
        severity: info
        given: $
        then:
        -   function: checkSecurity
            functionOptions:
                schemesPath:
                - securitySchemes
                nullable: true
                methods:
                - get
                - head
    sec-securitySchemes-oauth:
        description: |-
            Json Web Tokens RFC7519 is a compact, URL-safe means of representing
            claims to be transferred between two parties. JWT can be enclosed in
            encrypted or signed tokens like JWS and JWE.

            The [JOSE IANA registry](https://www.iana.org/assignments/jose/jose.xhtml)
            provides algorithms information.

            RFC8725 describes common pitfalls in the JWx specifications and in
            their implementations, such as:
            - the ability to ignore algorithms, eg. `{"alg": "none"}`;
            - using insecure algorithms like `RSASSA-PKCS1-v1_5` eg. `{"alg": "RS256"}`.

            An API using JWT should explicit in the `description`
            that the implementation conforms to RFC8725.

            ```
            components:
              securitySchemes:
                JWTBearer:
                  type: http
                  scheme: bearer
                  bearerFormat: JWT
                  description: |-
                    A bearer token in the format of a JWS and conformato
                    to the specifications included in RFC8725.
            ```
        message: JWT usage should be detailed in `description` {{error}}.
        given:
        - $..[securitySchemes][?(@.type=="oauth2")]
        then:
        -   field: description
            function: truthy
        -   field: description
            function: pattern
            functionOptions:
                match: .*RFC8725.*
    sec-securitySchemes-jwt:
        description: |-
            Json Web Tokens RFC7519 is a compact, URL-safe means of representing
            claims to be transferred between two parties. JWT can be enclosed in
            encrypted or signed tokens like JWS and JWE.

            The [JOSE IANA registry](https://www.iana.org/assignments/jose/jose.xhtml)
            provides algorithms information.

            RFC8725 describes common pitfalls in the JWx specifications and in
            their implementations, such as:
            - the ability to ignore algorithms, eg. `{"alg": "none"}`;
            - using insecure algorithms like `RSASSA-PKCS1-v1_5` eg. `{"alg": "RS256"}`.

            An API using JWT should explicit in the `description`
            that the implementation conforms to RFC8725.

            ```
            components:
              securitySchemes:
                JWTBearer:
                  type: http
                  scheme: bearer
                  bearerFormat: JWT
                  description: |-
                    A bearer token in the format of a JWS and conformato
                    to the specifications included in RFC8725.
            ```
        message: JWT usage should be detailed in `description` {{error}}.
        given:
        - $..[securitySchemes][?(@.bearerFormat=="jwt" || @.bearerFormat=="JWT")]
        then:
        -   field: description
            function: truthy
        -   field: description
            function: pattern
            functionOptions:
                match: .*RFC8725.*
    sec-apikeys-cookie:
        description: |-
            API Keys are (usually opaque) strings that
            are passed in headers, cookies or query parameters
            to access APIs.

            Those keys can be eavesdropped, especially when they are stored
            in cookies or passed as URL parameters.

            ```
            security:
            - ApiKey: []
            paths:
              /books: {}
              /users: {}
            securitySchemes:
              ApiKey:
                type: apiKey
                in: cookie
                name: X-Api-Key
            ```
        message: 'ApiKey stored in cookie or passed in URL: {{error}}.'
        formats:
        - oas3
        severity: error
        recommended: true
        given:
        - $..[securitySchemes][?(@.type=="apiKey")].in
        then:
        -   function: pattern
            functionOptions:
                notMatch: ^(cookie)$
    sec-auth-insecure-schemes:
        description: |-
            The http authorization type in OAS supports
            all the schemes defined in the associated
            [IANA table](https://www.iana.org/assignments/http-authschemes/).

            Some of those schemes are
            now considered insecure, such as
            negotiating authentication using specifications
            like NTLM or OAuth v1.
        message: 'Authentication scheme is insecure: {{error}}'
        formats:
        - oas3
        recommended: true
        severity: error
        given:
        - $..[securitySchemes][?(@.type=="http")].scheme
        then:
        -   function: pattern
            functionOptions:
                notMatch: ^(negotiate|oauth)$
    sec-string-maxlength:
        description: |-
            String length should be limited to avoid an attacker
            to send very long strings to your service.

            You can do this in different ways:
            - specify a `maxLength`
            - constraint the possible values with an `enum`
            - use a constrained `format` like `date` or `date-time`.

            A constrained string using the `date` format.

            ```
            ConstrainedString:
              type: string
              format: date
            ```

            Another constrained string using `maxLength`.
            You can always add further constraints using a
            `pattern` or a `format`.

            ```
            ZipCode:
              type: string
              maxLength: 5
              pattern: '[0-9]{5}'
            ```

            For further security, you can always limit string length even
            in conjunction with `format` and `pattern`.
        message: Strings (non enum) must specify a maximum length. {{path}} {{error}}
        formats:
        - oas3
        severity: warn
        recommended: true
        given:
        - $..[?(@.type=="string" && !@.enum && @.format!="date" && @.format !="date-time"
            )]
        then:
        -   field: maxLength
            function: defined
    sec-string-pattern-or-format-or-enum:
        description: |-
            String length should be limited to avoid an attacker
            to send very long strings to your service.

            You can do this in different ways:
            - specify a `maxLength`
            - constraint the possible values with an `enum`
            - use a constrained `format` like `date` or `date-time`.

            A constrained string using the `date` format.

            ```
            ConstrainedString:
              type: string
              format: date
            ```

            Another constrained string using `maxLength`.
            You can always add further constraints using a
            `pattern` or a `format`.

            ```
            ZipCode:
              type: string
              maxLength: 5
              pattern: '[0-9]{5}'
            ```

            For further security, you can always limit string length even
            in conjunction with `format` and `pattern`.
        message: Strings (non enum) must specify a pattern or a format. {{path}}
        formats:
        - oas3
        severity: hint
        recommended: true
        given:
        - $..[?(@.type=="string" && !@.enum && @.format!="date" && @.format !="date-time"
            )]
        then:
            function: schema
            functionOptions:
                schema:
                    type: object
                    anyOf:
                    -   required:
                        - pattern
                    -   required:
                        - format
                    additionalProperties: true
functions:
- checkSecurity
