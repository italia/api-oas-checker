#
# These rules are based on the Italian API Guidelines,
# which are meant to align the design and security requirements
# for the APIs provided by more that 20'000 administrations.
#
# Ruleset integrate the current HTTP specifications and a wide set of Best Current Practices
# currently adopted both in the private and the public sector.
#
# You can discuss the ruleset on github:
# - https://github.com/italia/api-oas-checker
#
extends: spectral:oas

rules:
  sec-array-boundaries:
    description: >-
      Array size should be limited to mitigate resource exhaustion
      attacks.

      This can be done using `maxItems` and `minItems`, like in the example

      below.


      ```

      Limited:
        type: array
        maxItems: 10
        items:
          type: string
          format: date
      ```


      You should ensure that the schema referenced in  `items` is constrained too.


      If you delegate input validation to a library or framework,

      be sure to test it thoroughly and ensure that it verifies `maxItems`.
    message: Schema of type array must specify maxItems and minItems. {{path}} {{error}}
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $..[?(@.type=="array")]
    then:
      - field: maxItems
        function: defined
      - field: minItems
        function: defined
  sec-number-boundaries:
    description: |-
      Numeric values should be limited in size to mitigate resource exhaustion
      using `maximum` and `minimum`.

      If you delegate input validation to a library or framework,
      be sure to test it thoroughly.
    message: Schema of type number or integer must specify a maximum and a minimum.
      {{path}} {{error}}
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $..[?(@.type=="number")]
      - $..[?(@.type=="integer")]
    then:
      - field: maximum
        function: defined
      - field: minimum
        function: defined
  sec-no-additionalProperties:
    description: |-
      By default, jsonschema allows additionalProperties. This means
      that schema validators can be bypassed using further, unspecified
      fields.

      While forbidding additionalProperties can create rigidity and hinder
      the evolution of an API - eg making it hard to accept new parameters
      or fields - it is possible that this flexibility can be used
      to bypass the schema validator and force the application to process
      unwanted information.

      Disable `additionalProperties` with `false`

      ```
      Person:
        type: object
        additionalProperties: false
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```

      Or constraint them using `maxProperties`

      ```
      Person:
        type: object
        additionalProperties:
          type: string
          pattern: /+39[0-9]{,14}/
        maxProperties: 3
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```
      - no additionalProperties
      - constrained additionalProperties
    message: "Objects should not allow unconstrained additionalProperties. Disable
      them with `additionalProperties: false` or add `maxProperties`."
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $..[?(@.type=="object" && @.additionalProperties==true)]
    then:
      - field: additionalProperties
        function: falsy
  sec-no-default-additionalProperties:
    description: |-
      By default, jsonschema allows additionalProperties. This means
      that schema validators can be bypassed using further, unspecified
      fields.

      While forbidding additionalProperties can create rigidity and hinder
      the evolution of an API - eg making it hard to accept new parameters
      or fields - it is possible that this flexibility can be used
      to bypass the schema validator and force the application to process
      unwanted information.

      Disable `additionalProperties` with `false`

      ```
      Person:
        type: object
        additionalProperties: false
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```

      Or constraint them using `maxProperties`

      ```
      Person:
        type: object
        additionalProperties:
          type: string
          pattern: /+39[0-9]{,14}/
        maxProperties: 3
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```
      - no additionalProperties
      - constrained additionalProperties
    message: "Objects should not allow unconstrained additionalProperties. Disable
      them with `additionalProperties: false` or add `maxProperties`."
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $..[?(@.type=="object" && ! @.additionalProperties)]
    then:
      - field: additionalProperties
        function: defined
  sec-constrained-additionalProperties:
    description: |-
      By default, jsonschema allows additionalProperties. This means
      that schema validators can be bypassed using further, unspecified
      fields.

      While forbidding additionalProperties can create rigidity and hinder
      the evolution of an API - eg making it hard to accept new parameters
      or fields - it is possible that this flexibility can be used
      to bypass the schema validator and force the application to process
      unwanted information.

      Disable `additionalProperties` with `false`

      ```
      Person:
        type: object
        additionalProperties: false
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```

      Or constraint them using `maxProperties`

      ```
      Person:
        type: object
        additionalProperties:
          type: string
          pattern: /+39[0-9]{,14}/
        maxProperties: 3
        properties:
          given_name:
            type: string
            pattern: [a-zA-Z ]{24}
      ```
      - no additionalProperties
      - constrained additionalProperties
    message: "Objects should not allow unconstrained additionalProperties. Disable
      them with `additionalProperties: false` or add `maxProperties`."
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $..[?(@.type=="object" && @.additionalProperties
        &&  @.additionalProperties!=true &&  @.additionalProperties!=false )]
    then:
      - field: maxProperties
        function: defined
  sec-protection-global-unsafe:
    description: |-
      Check if the operation is protected at operation level.
      Otherwise, the global `#/security` property is check.

      Your API should be protected by a `security` rule either at
      global or operation level.
      All operations should be protected especially when they
      not safe (methods that do not alter the state of the server) 
      HTTP methods like `POST`, `PUT`, `PATCH` and `DELETE`.
      This is done with one or more non-empty `security` rules.

      Security rules are defined in the `securityScheme` section.

      An example of a security rule applied at global level.

      ```
      security:
      - BasicAuth: []
      paths:
        /books: {}
        /users: {}
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
      ```

      An example of a security rule applied at operation level, which
      eventually overrides the global one

      ```
      paths:
        /books:
          post:
            security:
            - AccessToken: []
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
        AccessToken:
          scheme: http
          type: bearer
          bearerFormat: JWT
      ```
    message: "The following unsafe operation is not protected by a `security` rule:
      {{path}}"
    severity: error
    given: $
    then:
      - function: checkSecurity
        functionOptions:
          schemesPath:
            - securitySchemes
          nullable: true
          methods:
            - post
            - patch
            - delete
            - put
  sec-protection-global-unsafe-strict:
    description: |-
      Check if the operation is protected at operation level.
      Otherwise, the global `#/security` property is check.

      Your API should be protected by a `security` rule either at
      global or operation level.
      All operations should be protected especially when they
      not safe (methods that do not alter the state of the server) 
      HTTP methods like `POST`, `PUT`, `PATCH` and `DELETE`.
      This is done with one or more non-empty `security` rules.

      Security rules are defined in the `securityScheme` section.

      An example of a security rule applied at global level.

      ```
      security:
      - BasicAuth: []
      paths:
        /books: {}
        /users: {}
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
      ```

      An example of a security rule applied at operation level, which
      eventually overrides the global one

      ```
      paths:
        /books:
          post:
            security:
            - AccessToken: []
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
        AccessToken:
          scheme: http
          type: bearer
          bearerFormat: JWT
      ```
    message: "The following unsafe operation is not protected by a `security` rule:
      {{path}}"
    severity: info
    given: $
    then:
      - function: checkSecurity
        functionOptions:
          schemesPath:
            - securitySchemes
          nullable: false
          methods:
            - post
            - patch
            - delete
            - put
  sec-protection-global-safe:
    description: |-
      Check if the operation is protected at operation level.
      Otherwise, the global `#/security` property is check.

      Your API should be protected by a `security` rule either at
      global or operation level.
      All operations should be protected especially when they
      not safe (methods that do not alter the state of the server) 
      HTTP methods like `POST`, `PUT`, `PATCH` and `DELETE`.
      This is done with one or more non-empty `security` rules.

      Security rules are defined in the `securityScheme` section.

      An example of a security rule applied at global level.

      ```
      security:
      - BasicAuth: []
      paths:
        /books: {}
        /users: {}
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
      ```

      An example of a security rule applied at operation level, which
      eventually overrides the global one

      ```
      paths:
        /books:
          post:
            security:
            - AccessToken: []
      securitySchemes:
        BasicAuth:
          scheme: http
          type: basic
        AccessToken:
          scheme: http
          type: bearer
          bearerFormat: JWT
      ```
    message: "The following operation is not protected by a `security` rule: {{path}}"
    severity: info
    given: $
    then:
      - function: checkSecurity
        functionOptions:
          schemesPath:
            - securitySchemes
          nullable: true
          methods:
            - get
            - head
  sec-securitySchemes-oauth:
    description: >-
      Json Web Tokens RFC7519 is a compact, URL-safe means of
      representing

      claims to be transferred between two parties. JWT can be enclosed in

      encrypted or signed tokens like JWS and JWE.


      The [JOSE IANA registry](https://www.iana.org/assignments/jose/jose.xhtml)

      provides algorithms information.


      RFC8725 describes common pitfalls in the JWx specifications and in

      their implementations, such as:

      - the ability to ignore algorithms, eg. `{"alg": "none"}`;

      - using insecure algorithms like `RSASSA-PKCS1-v1_5` eg. `{"alg": "RS256"}`.


      An API using JWT should explicit in the `description`

      that the implementation conforms to RFC8725.


      ```

      components:
        securitySchemes:
          JWTBearer:
            type: http
            scheme: bearer
            bearerFormat: JWT
            description: |-
              A bearer token in the format of a JWS and conformato
              to the specifications included in RFC8725.
      ```
    message: JWT usage should be detailed in `description` {{error}}.
    given:
      - $..[securitySchemes][?(@.type=="oauth2")]
    then:
      - field: description
        function: truthy
      - field: description
        function: pattern
        functionOptions:
          match: .*RFC8725.*
  sec-securitySchemes-jwt:
    description: >-
      Json Web Tokens RFC7519 is a compact, URL-safe means of
      representing

      claims to be transferred between two parties. JWT can be enclosed in

      encrypted or signed tokens like JWS and JWE.


      The [JOSE IANA registry](https://www.iana.org/assignments/jose/jose.xhtml)

      provides algorithms information.


      RFC8725 describes common pitfalls in the JWx specifications and in

      their implementations, such as:

      - the ability to ignore algorithms, eg. `{"alg": "none"}`;

      - using insecure algorithms like `RSASSA-PKCS1-v1_5` eg. `{"alg": "RS256"}`.


      An API using JWT should explicit in the `description`

      that the implementation conforms to RFC8725.


      ```

      components:
        securitySchemes:
          JWTBearer:
            type: http
            scheme: bearer
            bearerFormat: JWT
            description: |-
              A bearer token in the format of a JWS and conformato
              to the specifications included in RFC8725.
      ```
    message: JWT usage should be detailed in `description` {{error}}.
    given:
      - $..[securitySchemes][?(@.bearerFormat=="jwt" || @.bearerFormat=="JWT")]
    then:
      - field: description
        function: truthy
      - field: description
        function: pattern
        functionOptions:
          match: .*RFC8725.*
  sec-apikeys-cookie:
    description: |-
      API Keys are (usually opaque) strings that
      are passed in headers, cookies or query parameters
      to access APIs.

      Those keys can be eavesdropped, especially when they are stored
      in cookies or passed as URL parameters.

      ```
      security:
      - ApiKey: []
      paths:
        /books: {}
        /users: {}
      securitySchemes:
        ApiKey:
          type: apiKey
          in: cookie
          name: X-Api-Key
      ```
    message: "ApiKey stored in cookie or passed in URL: {{error}}."
    formats:
      - oas3
    severity: error
    recommended: true
    given:
      - $..[securitySchemes][?(@.type=="apiKey")].in
    then:
      - function: pattern
        functionOptions:
          notMatch: ^(cookie)$
  sec-auth-insecure-schemes:
    description: |-
      The http authorization type in OAS supports
      all the schemes defined in the associated
      [IANA table](https://www.iana.org/assignments/http-authschemes/).

      Some of those schemes are
      now considered insecure, such as
      negotiating authentication using specifications
      like NTLM or OAuth v1.
    message: "Authentication scheme is insecure: {{error}}"
    formats:
      - oas3
    recommended: true
    severity: error
    given:
      - $..[securitySchemes][?(@.type=="http")].scheme
    then:
      - function: pattern
        functionOptions:
          notMatch: ^(negotiate|oauth)$
  sec-string-maxlength:
    description: |-
      String length should be limited to avoid an attacker
      to send very long strings to your service.

      You can do this in different ways:
      - specify a `maxLength`
      - constraint the possible values with an `enum`
      - use a constrained `format` like `date` or `date-time`.

      A constrained string using the `date` format.

      ```
      ConstrainedString:
        type: string
        format: date
      ```

      Another constrained string using `maxLength`.
      You can always add further constraints using a
      `pattern` or a `format`.

      ```
      ZipCode:
        type: string
        maxLength: 5
        pattern: '[0-9]{5}'
      ```

      For further security, you can always limit string length even
      in conjunction with `format` and `pattern`.
    message: Strings (non enum) must specify a maximum length. {{path}} {{error}}
    formats:
      - oas3
    severity: warn
    recommended: true
    given:
      - $..[?(@.type=="string" && !@.enum && @.format!="date" && @.format
        !="date-time" )]
    then:
      - field: maxLength
        function: defined
  sec-string-pattern-or-format-or-enum:
    description: |-
      String length should be limited to avoid an attacker
      to send very long strings to your service.

      You can do this in different ways:
      - specify a `maxLength`
      - constraint the possible values with an `enum`
      - use a constrained `format` like `date` or `date-time`.

      A constrained string using the `date` format.

      ```
      ConstrainedString:
        type: string
        format: date
      ```

      Another constrained string using `maxLength`.
      You can always add further constraints using a
      `pattern` or a `format`.

      ```
      ZipCode:
        type: string
        maxLength: 5
        pattern: '[0-9]{5}'
      ```

      For further security, you can always limit string length even
      in conjunction with `format` and `pattern`.
    message: Strings (non enum) must specify a pattern or a format. {{path}}
    formats:
      - oas3
    severity: hint
    recommended: true
    given:
      - $..[?(@.type=="string" && !@.enum && @.format!="date" && @.format
        !="date-time" )]
    then:
      function: schema
      functionOptions:
        schema:
          type: object
          anyOf:
            - required:
                - pattern
            - required:
                - format
          additionalProperties: true
functions:
  - checkSecurity

