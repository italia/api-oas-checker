rules:
  paths-status:
    x-tags:
    - it
    description: |-
      You must define a `/status` path that can be used to health-check the API.
      Using this path avoids the arbitrary usage of a server URL for health-check
      scope.

      The `/status` endpoint should return a `application/problem+json` response
      containing a successful status code if the service is working correctly.

      The service provider is free to define the implementation logic for this path.
    message: >-
      The "/status" path used to health-check the API must be defined. {{error}}
    severity: error
    recommended: true
    given: $
    then:
      field: "paths./status.get.responses.200"
      function: truthy  
  paths-status-return-problem:
    x-tags:
    - it
    description: |-
      "/status" must return a Problem object.
    message: |-
      {{error}}
    severity: error
    recommended: true
    given: >-
      $.paths.'/status'.get.responses.200.content.*~
    then:
      function: enumeration
      functionOptions:
        values:
        - application/problem+xml
        - application/problem+json  
  paths-status-problem-schema:
    x-tags:
    - it
    description: |-
      "/status" schema is not a Problem object.
      
      It is possible to reuse the [schema provided here](https://github.com/teamdigitale/openapi/blob/master/docs/schemas/problem.yaml),
      extend it or reference it.
      
      ```
      schemas:
        Problem:
          $ref: "https://teamdigitale.github.io/openapi/0.0.7/definitions.yaml#/schemas/Problem"
      ```
      
    message: |-
      {{error}} {{path}}
    severity: warn
    recommended: true
    given: >-
      $.paths.'/status'.get.responses.200.content.[[schema]]
    then:
    - function: truthy
      field: 'properties.status'
    - function: truthy
      field: 'properties.title'
    - function: truthy
      field: 'properties.detail'
  paths-http-method:
    x-tags:
      - it
    description: |-
      When you design a REST API, you don't usually need to mention terms like
      `get`, `delete` and so on in your `paths`, because this information is
      conveyed by the HTTP method.

      Instead of using

      ```
      POST /books/1234/delete HTTP/1.1
      Host: api.example
      ```

      You can simply call

      ```
      DELETE /books/1234 HTTP/1.1
      Host: api.example
      ```

      Similarly you don't need verbs like `list` or `create` because
      the HTTP Semantics RFC7231 supports this kind of actions natively
      with proper methods and status code.

      Instead of

      ```
      POST /create/user HTTP/1.1
      Host: api.example
      Content-Type: application/json

      {"given_name": "Mario"}
      ```

      You can use
      ```
      POST /create/user HTTP/1.1
      Host: api.example
      Content-Type: application/json

      {"given_name": "Mario"}
      ```

      returning a proper response

      ```
      HTTP/1.1 201 Created
      Location: /users/1234

      ```

      This simplifies securing your API as you know beforehand the kind of action
      which is going to be performed.
    message: >-
      API "path" contains a name of an http method. {{error}}
    severity: hint
    recommended: true
    given:
      - >-
        $.paths[?(@property.match(
        /\/(get|post|put|delete|patch)[\/A-Z_\-]?/
        ))]~
      - >-
        $.paths[?(@property.match(
        /\/(create|remove|list)[\/A-Z_\-]?/
        ))]~

    then:
      field: "@key"
      function: undefined

